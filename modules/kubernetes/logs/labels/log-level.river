// log_level sets a default log level of "unknown", then based on known
// patterns, attemps to assign an appropriate log level based on the contents
// of the log line. This component should be considered as default/initial
// processing as there are components for parsing specific log patterns.
declare "log_level" {
	argument "forward_to" {
		// comment = "Must be a list(LogsReceiver) where collected logs should be forwarded to"
		optional = false
	}

	export "process" {
		value = loki.process.log_level
	}

	loki.process "log_level" {
		forward_to = argument.forward_to.value

		// if a log level is not set, default it to unknown
		stage.match {
			selector = "{level=\"\"}"

			// default level to unknown
			stage.static_labels {
				values = {
					level = "unknown",
				}
			}
		}

		// if a log_type is not set, default it to unknown
		stage.match {
			selector = "{log_type=\"\"}"

			// default level to unknown
			stage.static_labels {
				values = {
					log_type = "unknown",
				}
			}
		}

		// check to see if the log line matches the klog format (https://github.com/kubernetes/klog)
		stage.match {
			// unescaped regex: ([IWED][0-9]{4}\s+[0-9]{2}:[0-9]{2}:[0-9]{2}\.[0-9]+)
			selector = "{level=\"unknown\"} |~ \"([IWED][0-9]{4}\\\\s+[0-9]{2}:[0-9]{2}:[0-9]{2}\\\\.[0-9]+)\""

			// extract log level, klog uses a single letter code for the level followed by the month and day i.e. I0119
			stage.regex {
				expression = "((?P<level>[A-Z])[0-9])"
			}

			// if the extracted level is I set INFO
			stage.replace {
				source     = "level"
				expression = "(I)"
				replace    = "INFO"
			}

			// if the extracted level is W set WARN
			stage.replace {
				source     = "level"
				expression = "(W)"
				replace    = "WARN"
			}

			// if the extracted level is E set ERROR
			stage.replace {
				source     = "level"
				expression = "(E)"
				replace    = "ERROR"
			}

			// if the extracted level is I set INFO
			stage.replace {
				source     = "level"
				expression = "(D)"
				replace    = "DEBUG"
			}

			// set the extracted level to be a label
			stage.labels {
				values = {
					level = "",
				}
			}
		}

		// if the level is still unknown, do one last attempt at detecting it based on common levels
		stage.match {
			selector = "{level=\"unknown\"}"

			// unescaped regex: (?i)(?:"(?:level|loglevel|levelname|lvl|SeverityText)":\s*"|\s+(?:level|loglevel|lvl)="?|\s+\[?)(?P<level>(DEBUG?|INFO|WARN(ING)?|ERR(OR)?|CRITICAL|FATAL|NOTICE|TRACE))("|\s+|-|\s*\])
			stage.regex {
				expression = "(?i)(?:\"(?:level|loglevel|levelname|lvl|SeverityText)\":\\s*\"|\\s+(?:level|loglevel|lvl)=\"?|\\s+\\[?)(?P<level>(DEBUG?|INFO|WARN(ING)?|ERR(OR)?|CRITICAL|FATAL|NOTICE|TRACE))(\"|\\s+|-|\\s*\\])"
			}

			// set the extracted level to be a label
			stage.labels {
				values = {
					level = "",
				}
			}
		}
	}
}

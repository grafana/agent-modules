/*
Module: job-agent
Description: Scrapes grafana agent

Note: Every argument except for "forward_to" is optional, and does have a defined default value.  However, the values for these
      arguments are not defined using the default = " ... " argument syntax, but rather using the coalesce(argument.value, " ... ").
      This is because if the argument passed in from another consuming module is set to null, the default = " ... " syntax will
      does not override the value passed in, where coalesce() will return the first non-null value.
*/
argument "forward_to" {
  comment = "Must be a list(MetricsReceiver) where collected logs should be forwarded to"
}

argument "role" {
  comment = "The role to use when looking for targets to scrape via annotations, can be: endpoints, service, pod (default: pod)"
  optional = true
}

argument "namespaces" {
  comment = "The namespaces to look for targets in (default: [] is all namespaces)"
  optional = true
}

argument "annotation" {
  // Docs: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  // k8s selectors d not support a logical OR, if multiple types of annotations are needed, this module should be invoked multiple times
  // i.e. metrics.agent.grafana.com, then again for prometheus.io
  comment = "The annotation namespace to use (default: metrics.agent.grafana.com)"
  optional = true
}

argument "sd_annotation" {
  // While service discovery can use special characters i.e. a ".", "-", or "/" in the annotation name, relabeling cannot.  these characters
  // i.e. metrics.agent.grafana.com becomes metrics_agent_grafana_com
  comment = "The annotation namespace to use (default: metrics.agent.grafana.com)"
  default = to_lower(replace("/", "_", replace("-", "_", replace(".", "_", coalesce(argument.annotation.value, "metrics.agent.grafana.com")))))
  optional = true
}

argument "tenant" {
  comment = "The tenant to write metrics to.  This does not have to be the tenantId, this is the value to look for in the logs.agent.grafana.com/tenant annotation, and this can be a regex."
  optional = true
  default = ".*"
}

argument "keep_metrics" {
  comment = "A regex of metrics to keep (default: (.+))"
  optional = true
}

argument "drop_metrics" {
  comment = "A regex of metrics to drop (default: \"\")"
  optional = true
}

argument "scrape_port_named_metrics" {
  comment = "Whether or not to automatically scrape endpoints that have a port with 'metrics' in the name"
  optional = true
  default = false
}

argument "scrape_interval" {
  comment = "How often to scrape metrics from the targets (default: 60s)"
  optional = true
}

argument "max_cache_size" {
  comment = "The maximum number of elements to hold in the relabeling cache (default: 100000).  Only increase if the amount of metrics returned is extremely large, the default will almost always be sufficient"
  optional = true
}

argument "clustering" {
  // Docs: https://grafana.com/docs/agent/latest/flow/concepts/clustering/
  comment = "Whether or not clustering should be enabled (default: false)"
  optional = true
}

// annotations service discovery
discovery.kubernetes "agent" {
  role = coalesce(argument.role.value, "endpoints")

  selectors {
    role = coalesce(argument.role.value, "endpoints")
    label = join(coalesce(argument.annotation.value, ["metrics.agent.grafana.com/scrape=true"]), ",")
  }

  namespaces {
    names = coalesce(argument.namespaces.value, [])
  }
}

discovery.relabel "annotations" {
  targets = discovery.kubernetes.agent.targets

  // allow resources to declare their metrics scraped or not
  // Example Annotation:
  //   metrics.agent.grafana.com/scrape: false
  //
  // the label prometheus.io/service-monitor: "false" is a common label for headless services, when performing endpoint
  // service discovery, if there is both a load-balanced service and headless service, this can result in duplicate
  // scrapes if the name of the service is attached as a label.  any targets with this label or annotation set should be dropped

  rule {
    action = "replace"
    replacement = "false"
    target_label = "__tmp_scrape"
  }

  rule {
    action = "replace"
    source_labels = [
      "__meta_kubernetes_" + argument.role.value + "_annotation_" + argument.sd_annotation.value + "_scrape",
      "__meta_kubernetes_" + argument.role.value + "_label_prometheus_io_service_monitor",
    ]
    separator = ";"
    // only allow empty or true, otherwise defaults to false
    regex = "^(?:;*)?(true)(;|true)*$"
    replacement = "$1"
    target_label = "__tmp_scrape"
  }

  // allow resources to declare the protocol to use when collecting metrics, the default value is "http",
  // Example Annotation:
  //   metrics.agent.grafana.com/scheme: http
  rule {
    action = "replace"
    replacement = "http"
    target_label = "__scheme__"
  }
  rule {
    action = "replace"
    source_labels = [
      "__meta_kubernetes_" + argument.role.value + "_annotation_" + argument.sd_annotation.value + "_scheme",
    ]
    separator = ";"
    regex = "^(?:;*)?(https?).*$"
    replacement = "$1"
    target_label = "__scheme__"
  }

  // allow resources to declare the port to use when collecting metrics, the default value is the discovered port from
  // Example Annotation:
  //   metrics.agent.grafana.com/port: 9090
  rule {
    action = "replace"
    source_labels = [
      "__meta_kubernetes_" + argument.role.value + "_annotation_" + argument.sd_annotation.value + "_port",
    ]
    separator = ";"
    regex = "^(?:;*)?(\\d+).*$"
    replacement = "$1"
    target_label = "__tmp_port"
  }

  // allow resources to declare their the path to use when collecting their metrics, the default value is "/metrics",
  // Example Annotation:
  //   metrics.agent.grafana.com/path: /metrics/foo
  rule {
    action = "replace"
    replacement = "/metrics"
    target_label = "__metrics_path__"
  }
  rule {
    action = "replace"
    source_labels = [
      "__meta_kubernetes_" + argument.role.value + "_annotation_" + argument.sd_annotation.value + "_path",
    ]
    separator = ";"
    regex = "^(?:;*)?([^;]+).*$"
    replacement = "$1"
    target_label = "__metrics_path__"
  }

  // allow resources to declare their metrics the tenant their metrics should be sent to,
  // Example Annotation:
  //   metrics.agent.grafana.com/tenant: primary
  //
  // Note: This does not necessarily have to be the actual tenantId, it can be a friendly name as well that is simply used
  //       to determine if the metrics should be gathered for the current tenant
  rule {
    action = "replace"
    replacement = ""
    target_label = "__tmp_tenant"
  }
  rule {
    action = "replace"
    source_labels = [
      "__meta_kubernetes_" + argument.role.value + "_annotation_" + argument.sd_annotation.value + "_tenant",
    ]
    separator = ";"
    regex = "^(?:;*)?([^;]+).*$"
    replacement = "$1"
    target_label = "__tmp_tenant"
  }

  // allow resources to declare how often their metrics should be collected, the default value is 1m,
  // the following duration formats are supported (s|m|ms|h|d):
  // Example Annotation:
  //   metrics.agent.grafana.com/interval: 5m
  rule {
    action = "replace"
    replacement = "1m"
    target_label = "__scrape_interval__"
  }
  rule {
    action = "replace"
    source_labels = [
      "__meta_kubernetes_" + argument.role.value + "_annotation_" + argument.sd_annotation.value + "_interval",
    ]
    separator = ";"
    regex = "^(?:;*)?(\\d+(s|m|ms|h|d)).*$"
    replacement = "$1"
    target_label = "__scrape_interval__"
  }

  // allow resources to declare the timeout of the scrape request, the default value is 10s,
  // the following duration formats are supported (s|m|ms|h|d):
  // Example Annotation:
  //   metrics.agent.grafana.com/timeout: 30s
  rule {
    action = "replace"
    replacement = "10s"
    target_label = "__scrape_timeout__"
  }
  rule {
    action = "replace"
    source_labels = [
      "__meta_kubernetes_" + argument.role.value + "_annotation_" + argument.sd_annotation.value + "_timeout",
    ]
    separator = ";"
    regex = "^(?:;*)?(\\d+(s|m|ms|h|d)).*$"
    replacement = "$1"
    target_label = "__scrape_timeout__"
  }

  // allow resources to declare their the job label value to use when collecting their metrics, the default value is "",
  // Example Annotation:
  //   metrics.agent.grafana.com/job: integrations/kubernetes/cadvisor
  rule {
    action = "replace"
    source_labels = [
      "__meta_kubernetes_" + argument.role.value + "_annotation_" + argument.sd_annotation.value + "_job",
    ]
    separator = ";"
    regex = "^(?:;*)?([^;]+).*$"
    replacement = "$1"
    target_label = "job"
  }

  // only keep targets where the pod is running or the pod_phase is empty and is not an init container.  This will only exist for role="pod" or
  // potentially role="endpoints", if it is a service the value is empty and thus allowed to pass, if it is an endpoint but not associated to a
  // pod but rather a static IP or hostname, that could be outside of kubernetes allow endpoints to declare what tenant their metrics should be
  // written to
  rule {
    action = "keep"
    source_labels = ["__meta_kubernetes_pod_phase"]
    regex = "^(?i)(Running|)$"
  }
  rule {
    action = "keep"
    source_labels = ["__meta_kubernetes_pod_ready"]
    regex = "^(true|)$"
  }
  // if the container is an init container, drop it
  rule {
    action = "drop"
    source_labels = ["__meta_kubernetes_pod_container_init"]
    regex = "^(true|)$"
  }

  // add a __tmp_scrape_port_named_metrics
  rule {
    replacement = format("%t", argument.scrape_port_named_metrics.value)
    target_label = "__tmp_scrape_port_named_metrics"
  }


  // set the target name label name label
  rule {
    action = "replace"
    source_labels = ["__meta_kubernetes_" + argument.role.value + "_name"]
    target_label = argument.role.value
  }

  // only keep targets that have scrape: true or "metrics" in the port name if the argument scrape_port_named_metrics
  rule {
    action = "keep"
    source_labels = [
      "__tmp_scrape",
      "__tmp_scrape_port_named_metrics",
      "__meta_kubernetes_endpoint_port_name",
    ]
    separator = ";"
    regex = "^(true;.*|(|true);true;(.*metrics.*))$"
  }

  // allow endpoints to declare what tenant their metrics should be written to,
  // Example Annotation:
  //   metrics.agent.grafana.com/tenant: "primary"
  rule {
    action = "keep"
    source_labels = ["__tmp_tenant"]
    regex = "^(" + argument.tenant.value + ")$"
  }

  // set the app name if specified as metadata labels "app:" or "app.kubernetes.io/name:"
  rule {
    action = "replace"
    source_labels = [
      "__meta_kubernetes_" + argument.role.value + "label_app_kubernetes_io_name",
      "__meta_kubernetes_" + argument.role.value + "label_k8s_app",
      "__meta_kubernetes_" + argument.role.value + "label_app",
    ]
    regex = "^(?:;*)?([^;]+).*$"
    replacement = "$1"
    target_label = "app"
  }

  // set the app component if specified as metadata labels "component:" or "app.kubernetes.io/component:"
  rule {
    action = "replace"
    source_labels = [
      "__meta_kubernetes_" + argument.role.value + "label_app_kubernetes_io_component",
      "__meta_kubernetes_" + argument.role.value + "label_component",
    ]
    regex = "^(?:;*)?([^;]+).*$"
    replacement = "$1"
    target_label = "component"
  }

  // add a controller label if the resource is a pod
  // example: grafana-agent-68nv9 becomes DaemonSet/grafana-agent
  rule {
    source_labels = [
      "__meta_kubernetes_pod_controller_kind",
      "__meta_kubernetes_pod_controller_name",
    ]
    action = "replace"
    regex = "^(.+);(.+)$"
    replacement = "$1/$2"
    target_label = "controller"
  }

}

// only keep http targets
discovery.relabel "http_annotations" {
  targets = discovery.relabel.annotations.output

  rule {
    action = "keep"
    source_labels = ["__scheme__"]
    regex ="http"
  }
}

// scrape http only targtets
prometheus.scrape "http_annotations" {
  job_name = "annotation-autodiscovery-http"
  forward_to = [discovery.relabel.annotations.receiver]
  targets = discovery.relabel.http_annotations.output
  scheme = "http"
  scrape_interval = coalesce(argument.scrape_interval.value, "60s")

  clustering {
    enabled = coalesce(argument.clustering.value, false)
  }
}

// only keep https targets
discovery.relabel "https_annotations" {
  targets = discovery.relabel.annotations.output

  rule {
    action = "keep"
    source_labels = ["__scheme__"]
    regex ="https"
  }
}

// scrape https only targtets
prometheus.scrape "https_annotations" {
  job_name = "annotation-autodiscovery-https"
  forward_to = [discovery.relabel.annotations.receiver]
  targets = discovery.relabel.https_annotations.output
  scheme = "https"
  scrape_interval = coalesce(argument.scrape_interval.value, "60s")
  bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"

  tls_config {
    ca_file = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
    insecure_skip_verify = false
    server_name = "kubernetes"
  }

  clustering {
    enabled = coalesce(argument.clustering.value, false)
  }

}

// perform generic relabeling using keep_metrics and drop_metrics
prometheus.relabel "annotations" {
  forward_to = argument.forward_to.value

  // keep only metrics that match the keep_metrics regex
  rule {
    source_labels = ["__name__"]
    regex = coalesce(argument.keep_metrics.value, "(.+)")
    action = "keep"
  }

  // drop metrics that match the drop_metrics regex
  rule {
    source_labels = ["__name__"]
    regex = coalesce(argument.drop_metrics.value, "")
    action = "drop"
  }
}

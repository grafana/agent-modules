/*
Module: job-opencost
Description: Scrapes opencost, this is a separate scrape job, if you are also using annotation based scraping, you will want to explicitly
             disable opencost from being scraped by this module and annotations by setting the following annotation on the opencost
             metrics.agent.grafana.com/scrape: "false"
*/
argument "forward_to" {
  comment = "Must be a list(MetricsReceiver) where collected logs should be forwarded to"
  optional = false
}

argument "namespaces" {
  comment = "The namespaces to look for targets in"
  optional = true
  default = [] // [] is all namespaces
}

argument "selectors" {
  // see: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  comment = "The label selectors to use to find matching targets"
  optional = true
  default = [
    "app.kubernetes.io/name=opencost",
  ]
}

argument "port_name" {
  comment = "The of the port to scrape metrics from"
  optional = true
  default = "http"
}

argument "job_label" {
  comment = "The job label to add for all opencost metrics"
  optional = true
  default = "integrations/kubernetes/opencost"
}

argument "keep_metrics" {
  comment = "A regex of metrics to keep"
  optional = true
  default = "(up|container_(cpu|gpu|memory)_allocation(_bytes)?|deployment_match_labels|kubecost_(cluster_(info|management_cost|memory_working_set_bytes)|http_requests_total|http_response_(size_bytes|time_seconds)|load_balancer_cost|network_(internet|region|zone)_egress_cost|node_is_spot)|node_(cpu_hourly_cost|gpu_(count|hourly_cost)|ram_hourly_cost|total_hourly_cost)|opencost_build_info|pod_pvc_allocation|pv_hourly_cost|service_selector_labels|statefulSet_match_labels)"
}

argument "scrape_interval" {
  comment = "How often to scrape metrics from the targets"
  optional = true
  default = "60s"
}

argument "max_cache_size" {
  comment = "The maximum number of elements to hold in the relabeling cache.  This should only be increased if the amount of metrics returned is extremely large, the default will almost always be sufficient."
  optional = true
  default = 100000
}


argument "clustering" {
  comment = "Whether or not clustering should be enabled"
  optional = true
  default = false
}

// opencost service discovery
discovery.kubernetes "opencost" {
  role = "service"

  selectors {
    role = "service"
    label = join(argument.selectors.value, ",")
  }

  namespaces {
    names = argument.namespaces.value
  }
}

// opencost relabelings (pre-scrape)
discovery.relabel "opencost" {
  targets = discovery.kubernetes.opencost.targets

  rule {
    source_labels = ["__meta_kubernetes_service_port_name"]
    regex = argument.port_name.value
    action = "keep"
  }
}

// opencost scrape job
prometheus.scrape "opencost" {
  job_name = argument.job_label.value
  forward_to = [prometheus.relabel.opencost.receiver]
  targets = discovery.relabel.opencost.output
  scrape_interval = argument.scrape_interval.value

  clustering {
    enabled = argument.clustering.value
  }
}

// opencost metric relabelings (post-scrape)
prometheus.relabel "opencost" {
  forward_to = argument.forward_to.value
  max_cache_size = argument.max_cache_size.value

  rule {
    source_labels = ["__name__"]
    regex = argument.keep_metrics.value
    action = "keep"
  }
}
